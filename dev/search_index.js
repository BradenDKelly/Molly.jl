var documenterSearchIndex = {"docs":
[{"location":"#Molly.jl-1","page":"Home","title":"Molly.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Travis build status) (Image: AppVeyor build status) (Image: Coverage Status) (Image: Documentation)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Much of science can be explained by the movement and interaction of molecules. Molecular dynamics (MD) is a computational technique used to explore these phenomena, particularly for biological macromolecules. Molly.jl is a pure Julia implementation of MD.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"At the minute the package is a proof of concept for MD in Julia v1.0. It can simulate a system of atoms with arbitrary interactions as defined by the user. It can also read in pre-computed Gromacs topology and coordinate files with the OPLS-AA forcefield and run MD on proteins with given parameters. In theory it can do this for any regular protein. Implemented features include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Interface to allow definition of new forces, thermostats etc.\nNon-bonded interactions - Lennard-Jones Van der Waals/repulsion force, electrostatic Coulomb potential.\nBonded interactions - covalent bonds, bond angles, dihedral angles.\nAndersen thermostat.\nVelocity Verlet integration.\nExplicit solvent.\nPeriodic boundary conditions in a cubic box.\nNeighbour list to speed up calculation of non-bonded forces.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Features not yet implemented include:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Speed. Seriously, it's not fast yet - ~20x slower than GROMACS by some rough calculations. For reference most of the computational time in MD is spent in the force calculation, and most of that in calculation of non-bonded forces.\nForce fields other than OPLS-AA.\nEnergy minimisation.\nOther temperature or pressure coupling methods.\nProtein preparation - solvent box, add hydrogens etc.\nTrajectory/topology file format readers/writers.\nTrajectory analysis.\nParallelisation.\nGPU compatibility.\nUnit tests.","category":"page"},{"location":"#Usage-1","page":"Home","title":"Usage","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Simulation of an ideal gas:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Molly\n\nn_atoms = 100\nbox_size = 2.0 # nm\ntemperature = 298 # K\nmass = 10.0 # Relative atomic mass\n\natoms = [Atom(mass=mass, σ=0.3, ϵ=0.2) for i in 1:n_atoms]\ncoords = [Coordinates(rand(3) .* box_size) for i in 1:n_atoms]\nvelocities = [Velocity(mass, temperature) for i in 1:n_atoms]\ngeneral_inters =  Dict(\"LJ\" => LennardJones())\n\ns = Simulation(\n    simulator=VelocityVerlet(),\n    atoms=atoms,\n    general_inters=general_inters,\n    coords=coords,\n    velocities=velocities,\n    temperature=temperature,\n    box_size=box_size,\n    thermostat=AndersenThermostat(1.0),\n    loggers=[TemperatureLogger(100)],\n    timestep=0.002, # ps\n    n_steps=100_000\n)\n\nsimulate!(s)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Simulation of a protein:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Molly\n\ntimestep = 0.0002 # ps\ntemperature = 298 # K\nn_steps = 5000\n\natoms, specific_inter_lists, general_inters, nb_matrix, coords, box_size = readinputs(\n            joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_top_ff.top\"),\n            joinpath(dirname(pathof(Molly)), \"..\", \"data\", \"5XER\", \"gmx_coords.gro\"))\n\ns = Simulation(\n    simulator=VelocityVerlet(),\n    atoms=atoms,\n    specific_inter_lists=specific_inter_lists,\n    general_inters=general_inters,\n    coords=coords,\n    velocities=[Velocity(a.mass, temperature) for a in atoms],\n    temperature=temperature,\n    box_size=box_size,\n    neighbour_finder=DistanceNeighbourFinder(nb_matrix, 10),\n    thermostat=AndersenThermostat(1.0),\n    loggers=[TemperatureLogger(10), StructureWriter(10, \"traj_5XER_1ps.pdb\")],\n    timestep=timestep,\n    n_steps=n_steps\n)\n\nsimulate!(s)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The above 1 ps simulation looks something like this when you output more PDB files and view it in VMD: (Image: MD simulation)","category":"page"},{"location":"#Plans-1","page":"Home","title":"Plans","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"I plan to work on this in my spare time, but progress will be slow. MD could provide a nice use case for Julia - I think a reasonably featured and performant MD program could be written in fewer than 1,000 lines of code for example. Julia is also a well-suited language for trajectory analysis.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Contributions are very welcome - see the roadmap issue for more.","category":"page"},{"location":"docs/#Molly.jl-documentation-1","page":"Documentation","title":"Molly.jl documentation","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"These docs are work in progress - not every step works yet","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Molly takes a modular approach to molecular simulation. To run a simulation you create a Simulation object and run simulate! on it. The different components of the simulation can be used as defined by the package, or you can define your own versions.","category":"page"},{"location":"docs/#Simulating-an-ideal-gas-1","page":"Documentation","title":"Simulating an ideal gas","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Let's look at the simulation of an ideal gas to start with. First, we'll need some atoms with the relevant parameters defined.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"using Molly\n\nn_atoms = 100\nmass = 10.0\natoms = [Atom(mass=mass, σ=0.3, ϵ=0.2) for i in 1:n_atoms]","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Next, we'll need some starting coordinates and velocities.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"box_size = 2.0 # nm\ncoords = [Coordinates(rand(3) .* box_size) for i in 1:n_atoms]\n\ntemperature = 298 # K\nvelocities = [Velocity(mass, temperature) for i in 1:n_atoms]","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Now we can define our dictionary of general interactions, i.e. those between most or all atoms. Because we have defined the relevant parameters, we can use the built-in Lennard Jones type.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"general_inters =  Dict(\"LJ\" => LennardJones())","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Finally, we can define and run the simulation. We use an Andersen thermostat to keep a constant temperature, and we log the temperature and coordinates every 100 steps.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"s = Simulation(\n    simulator=VelocityVerlet(), # Use velocity Verlet integration\n    atoms=atoms,\n    general_inters=general_inters,\n    coords=coords,\n    velocities=velocities,\n    temperature=temperature,\n    box_size=box_size,\n    thermostat=AndersenThermostat(1.0), # Coupling constant of 1.0\n    loggers=[TemperatureLogger(100), CoordinateLogger(100)],\n    timestep=0.002, # ps\n    n_steps=100_000\n)\n\nsimulate!(s)","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"We can get a quick look at the simulation by plotting the coordinate logger.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"using Plots\npyplot(leg=false)\n\n@gif for coords in s.loggers[2]\n    plot(s.loggers[2], box_size)\nend","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"And can check the temperature by plotting the temperature logger.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"plot(s.loggers[1])","category":"page"},{"location":"docs/#Simulating-diatomic-molecules-1","page":"Documentation","title":"Simulating diatomic molecules","text":"","category":"section"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"If we want to define specific interactions between atoms, for example bonds, we can do. Using the same atom definitions as before, lets set up the coordinates so paired atoms are 1 Angstrom apart.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"coords = Coordinates[]\nfor i in 1:(n_atoms / 2)\n    c = rand(3) .* box_size\n    push!(coords, Coordinates(c))\n    push!(coords, Coordinates(c + [0.1, 0.0, 0.0]))\nend\n\nvelocities = [Velocity(mass, temperature) for i in 1:n_atoms]","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Now we can use the built-in bond type to place a harmonic constraint between paired atoms. The arguments are the indices of the two atoms in the bond, the equilibrium distance and the force constant.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"bonds = [Bond((i * 2) - 1, i * 2, 0.1, 300_000) for i in 1:(n_atoms / 2)]\n\nspecific_inter_lists = Dict(\"Bonds\" => bonds)","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"This time, we are also going to use a neighbour list to speed up the Lennard Jones calculation. We can use the built-in distance neighbour finder. The arguments are the number of steps between each update and the cutoff in nm to be classed as a neighbour. # Change so this is true","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"neighbour_finder = DistanceNeighbourFinder(10, 2.0)","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"Now we can simulate as before.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"s = Simulation(\n    simulator=VelocityVerlet()\n    atoms=atoms,\n    specific_inter_lists=specific_inter_lists,\n    general_inters=Dict(\"LJ\" => LennardJones(true)), # true means we are using the neighbour list for this interaction\n    coords=coords,\n    velocities=velocities,\n    temperature=temperature,\n    box_size=box_size,\n    neighbour_finder=neighbour_finder,\n    thermostat=AndersenThermostat(1.0),\n    loggers=[TemperatureLogger(100), CoordinateLogger(100)],\n    timestep=0.002,\n    n_steps=100_000\n)\n\nsimulate!(s)","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"This time when we view the trajectory we can add lines to show the bonds.","category":"page"},{"location":"docs/#","page":"Documentation","title":"Documentation","text":"connections = [((i * 2) - 1, i * 2) for i in 1:Int(n_atoms / 2)]\n\n@gif for coords in s.loggers[2]\n    plot(s.loggers[2], box_size, connections=connections)\nend","category":"page"},{"location":"docs/#Simulating-a-protein-in-the-OPLS-AA-forcefield-1","page":"Documentation","title":"Simulating a protein in the OPLS-AA forcefield","text":"","category":"section"}]
}
