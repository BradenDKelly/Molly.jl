<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · Molly.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Molly.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="docs.html">Documentation</a><ul class="internal"><li><a class="toctext" href="#Simulating-an-ideal-gas-1">Simulating an ideal gas</a></li><li><a class="toctext" href="#Simulating-diatomic-molecules-1">Simulating diatomic molecules</a></li><li><a class="toctext" href="#Simulating-a-protein-in-the-OPLS-AA-forcefield-1">Simulating a protein in the OPLS-AA forcefield</a></li><li><a class="toctext" href="#Defining-your-own-forces-1">Defining your own forces</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="docs.html">Documentation</a></li></ul><a class="edit-page" href="https://github.com/jgreener64/Molly.jl/blob/master/docs/src/docs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Molly-documentation-1" href="#Molly-documentation-1">Molly documentation</a></h1><p><em>These docs are work in progress</em></p><p>Molly takes a modular approach to molecular simulation. To run a simulation you create a <code>Simulation</code> object and run <code>simulate!</code> on it. The different components of the simulation can be used as defined by the package, or you can define your own versions.</p><h2><a class="nav-anchor" id="Simulating-an-ideal-gas-1" href="#Simulating-an-ideal-gas-1">Simulating an ideal gas</a></h2><p>Let&#39;s look at the simulation of an ideal gas to start with. First, we&#39;ll need some atoms with the relevant parameters defined.</p><pre><code class="language-julia">using Molly

n_atoms = 100
mass = 10.0
atoms = [Atom(mass=mass, σ=0.3, ϵ=0.2) for i in 1:n_atoms]</code></pre><p>Next, we&#39;ll need some starting coordinates and velocities.</p><pre><code class="language-julia">box_size = 2.0 # nm
coords = [box_size .* rand(SVector{3}) for i in 1:n_atoms]

temperature = 298 # K
velocities = [velocity(mass, temperature) for i in 1:n_atoms]</code></pre><p>We store the coordinates and velocities as <a href="https://github.com/JuliaArrays/StaticArrays.jl">static arrays</a> for performance. They can be of any number of dimensions and of any number type, e.g. <code>Float64</code> or <code>Float32</code>. Now we can define our dictionary of general interactions, i.e. those between most or all atoms. Because we have defined the relevant parameters for the atoms, we can use the built-in Lennard Jones type.</p><pre><code class="language-julia">general_inters = Dict(&quot;LJ&quot; =&gt; LennardJones())</code></pre><p>Finally, we can define and run the simulation. We use an Andersen thermostat to keep a constant temperature, and we log the temperature and coordinates every 100 steps.</p><pre><code class="language-julia">s = Simulation(
    simulator=VelocityVerlet(), # Use velocity Verlet integration
    atoms=atoms,
    general_inters=general_inters,
    coords=coords,
    velocities=velocities,
    temperature=temperature,
    box_size=box_size,
    thermostat=AndersenThermostat(1.0), # Coupling constant of 1.0
    loggers=Dict(&quot;temp&quot; =&gt; TemperatureLogger(100),
                    &quot;coords&quot; =&gt; CoordinateLogger(100)),
    timestep=0.002, # ps
    n_steps=100_000
)

simulate!(s)</code></pre><p>By default the simulation is run in parallel on the <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#man-multithreading-1">number of threads</a> available to Julia, but this can be turned off by giving the keyword argument <code>parallel=false</code> to <code>simulate!</code>. We can get a quick look at the simulation by plotting the coordinate and temperature loggers (in the future ideally this will be one easy plot command using recipes, and may switch to use Makie.jl).</p><pre><code class="language-julia">using Plots

coords = s.loggers[&quot;coords&quot;].coords
temps = s.loggers[&quot;temp&quot;].temperatures

splitcoords(coord) = [c[1] for c in coord], [c[2] for c in coord], [c[3] for c in coord]

@gif for (i, coord) in enumerate(coords)
    l = @layout [a b{0.7h}]

    cx, cy, cz = splitcoords(coord)
    p = scatter(cx, cy, cz,
        xlims=(0, box_size),
        ylims=(0, box_size),
        zlims=(0, box_size),
        layout=l,
        legend=false
    )

    plot!(p[2],
        temps[1:i],
        xlabel=&quot;Frame&quot;,
        ylabel=&quot;Temperature / K&quot;,
        xlims=(1, i),
        ylims=(0.0, maximum(temps[1:i])),
        legend=false
    )
end</code></pre><p><img src="images/sim_lj.gif" alt="LJ simulation"/></p><h2><a class="nav-anchor" id="Simulating-diatomic-molecules-1" href="#Simulating-diatomic-molecules-1">Simulating diatomic molecules</a></h2><p>If we want to define specific interactions between atoms, for example bonds, we can do. Using the same atom definitions as before, let&#39;s set up the coordinates so that paired atoms are 1 Å apart.</p><pre><code class="language-julia">coords = [box_size .* rand(SVector{3}) for i in 1:(n_atoms / 2)]
for i in 1:length(coords)
    push!(coords, coords[i] .+ [0.1, 0.0, 0.0])
end

velocities = [velocity(mass, temperature) for i in 1:n_atoms]</code></pre><p>Now we can use the built-in bond type to place a harmonic constraint between paired atoms. The arguments are the indices of the two atoms in the bond, the equilibrium distance and the force constant.</p><pre><code class="language-julia">bonds = [Bond(i, Int(i + n_atoms / 2), 0.1, 300_000.0) for i in 1:Int(n_atoms / 2)]

specific_inter_lists = Dict(&quot;Bonds&quot; =&gt; bonds)</code></pre><p>This time, we are also going to use a neighbour list to speed up the Lennard Jones calculation. We can use the built-in distance neighbour finder. The arguments are a 2D array of eligible interactions, the number of steps between each update and the cutoff in nm to be classed as a neighbour.</p><pre><code class="language-julia">neighbour_finder = DistanceNeighbourFinder(trues(n_atoms, n_atoms), 10, 1.2)</code></pre><p>Now we can simulate as before.</p><pre><code class="language-julia">s = Simulation(
    simulator=VelocityVerlet(),
    atoms=atoms,
    specific_inter_lists=specific_inter_lists,
    general_inters=Dict(&quot;LJ&quot; =&gt; LennardJones(true)), # true means we are using the neighbour list for this interaction
    coords=coords,
    velocities=velocities,
    temperature=temperature,
    box_size=box_size,
    neighbour_finder=neighbour_finder,
    thermostat=AndersenThermostat(1.0),
    loggers=Dict(&quot;temp&quot; =&gt; TemperatureLogger(100),
                    &quot;coords&quot; =&gt; CoordinateLogger(100)),
    timestep=0.002,
    n_steps=100_000
)

simulate!(s)</code></pre><p>This time when we view the trajectory we can add lines to show the bonds.</p><pre><code class="language-julia">using LinearAlgebra

coords = s.loggers[&quot;coords&quot;].coords
temps = s.loggers[&quot;temp&quot;].temperatures

connections = [(i, Int(i + n_atoms / 2)) for i in 1:Int(n_atoms / 2)]

@gif for (i, coord) in enumerate(coords)
    l = @layout [a b{0.7h}]

    cx, cy, cz = splitcoords(coord)
    p = scatter(cx, cy, cz,
        xlims=(0, box_size),
        ylims=(0, box_size),
        zlims=(0, box_size),
        layout=l,
        legend=false
    )

    for (a1, a2) in connections
        if norm(coord[a1] - coord[a2]) &lt; (box_size / 2)
            plot!(p[1],
                [cx[a1], cx[a2]],
                [cy[a1], cy[a2]],
                [cz[a1], cz[a2]],
                linecolor=&quot;lightblue&quot;
            )
        end
    end

    plot!(p[2],
        temps[1:i],
        xlabel=&quot;Frame&quot;,
        ylabel=&quot;Temperature / K&quot;,
        xlims=(1, i),
        ylims=(0.0, maximum(temps[1:i])),
        legend=false
    )
end</code></pre><p><img src="images/sim_diatomic.gif" alt="Diatomic simulation"/></p><h2><a class="nav-anchor" id="Simulating-a-protein-in-the-OPLS-AA-forcefield-1" href="#Simulating-a-protein-in-the-OPLS-AA-forcefield-1">Simulating a protein in the OPLS-AA forcefield</a></h2><p><em>In progress</em></p><h2><a class="nav-anchor" id="Defining-your-own-forces-1" href="#Defining-your-own-forces-1">Defining your own forces</a></h2><p><em>In progress</em></p><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
