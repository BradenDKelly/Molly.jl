<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Documentation · Molly.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Molly.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Home</a></li><li class="current"><a class="toctext" href="docs.html">Documentation</a><ul class="internal"><li><a class="toctext" href="#Simulating-a-gas-1">Simulating a gas</a></li><li><a class="toctext" href="#Simulating-diatomic-molecules-1">Simulating diatomic molecules</a></li><li><a class="toctext" href="#Simulating-gravity-1">Simulating gravity</a></li><li><a class="toctext" href="#Simulating-a-protein-1">Simulating a protein</a></li><li><a class="toctext" href="#Forces-1">Forces</a></li><li><a class="toctext" href="#Simulators-1">Simulators</a></li><li><a class="toctext" href="#Thermostats-1">Thermostats</a></li><li><a class="toctext" href="#Neighbour-finders-1">Neighbour finders</a></li><li><a class="toctext" href="#Loggers-1">Loggers</a></li><li><a class="toctext" href="#Analysis-1">Analysis</a></li></ul></li><li><a class="toctext" href="api.html">API</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="docs.html">Documentation</a></li></ul><a class="edit-page" href="https://github.com/JuliaMolSim/Molly.jl/blob/master/docs/src/docs.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Documentation</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Molly-documentation-1" href="#Molly-documentation-1">Molly documentation</a></h1><p>Molly takes a modular approach to molecular simulation. To run a simulation you create a <a href="api.html#Molly.Simulation"><code>Simulation</code></a> object and call <a href="api.html#Molly.simulate!-Tuple{Simulation,VelocityVerlet,Integer}"><code>simulate!</code></a> on it. The different components of the simulation can be used as defined by the package, or you can define your own versions. An important principle of the package is that your custom components, particularly force functions, should be easy to define and just as performant as the built-in versions.</p><p>This documentation will first introduce the main features of the package with some examples, then will give details on each component of a simulation. For more information on specific types or functions, see the <a href="api.html#Molly-API-1">Molly API</a> section or call <code>?function_name</code> in Julia.</p><h2><a class="nav-anchor" id="Simulating-a-gas-1" href="#Simulating-a-gas-1">Simulating a gas</a></h2><p>Let&#39;s look at the simulation of a gas acting under the <a href="https://en.wikipedia.org/wiki/Lennard-Jones_potential">Lennard-Jones</a> potential to start with. First, we&#39;ll need some atoms with the relevant parameters defined.</p><pre><code class="language-julia">using Molly

n_atoms = 100
mass = 10.0
atoms = [Atom(mass=mass, σ=0.3, ϵ=0.2) for i in 1:n_atoms]</code></pre><p>Next, we&#39;ll need some starting coordinates and velocities.</p><pre><code class="language-julia">box_size = 2.0 # nm
coords = [box_size .* rand(SVector{3}) for i in 1:n_atoms]

temperature = 100 # K
velocities = [velocity(mass, temperature) for i in 1:n_atoms]</code></pre><p>We store the coordinates and velocities as <a href="https://github.com/JuliaArrays/StaticArrays.jl">static arrays</a> for performance. They can be of any number of dimensions and of any number type, e.g. <code>Float64</code> or <code>Float32</code>. Now we can define our dictionary of general interactions, i.e. those between most or all atoms. Because we have defined the relevant parameters for the atoms, we can use the built-in Lennard Jones type.</p><pre><code class="language-julia">general_inters = Dict(&quot;LJ&quot; =&gt; LennardJones())</code></pre><p>Finally, we can define and run the simulation. We use an Andersen thermostat to keep a constant temperature, and we log the temperature and coordinates every 10 steps.</p><pre><code class="language-julia">s = Simulation(
    simulator=VelocityVerlet(), # Use velocity Verlet integration
    atoms=atoms,
    general_inters=general_inters,
    coords=coords,
    velocities=velocities,
    temperature=temperature,
    box_size=box_size,
    thermostat=AndersenThermostat(1.0), # Coupling constant of 1.0
    loggers=Dict(&quot;temp&quot; =&gt; TemperatureLogger(10),
                    &quot;coords&quot; =&gt; CoordinateLogger(10)),
    timestep=0.002, # ps
    n_steps=1_000
)

simulate!(s)</code></pre><p>By default the simulation is run in parallel on the <a href="https://docs.julialang.org/en/v1/manual/parallel-computing/#man-multithreading-1">number of threads</a> available to Julia, but this can be turned off by giving the keyword argument <code>parallel=false</code> to <a href="api.html#Molly.simulate!-Tuple{Simulation,VelocityVerlet,Integer}"><code>simulate!</code></a>. An animation of the stored coordinates using can be saved using <a href="api.html#Molly.visualize"><code>visualize</code></a>, which is available when <a href="https://github.com/JuliaPlots/Makie.jl">Makie.jl</a> is imported.</p><pre><code class="language-julia">using Makie

visualize(s.loggers[&quot;coords&quot;], box_size, &quot;sim_lj.gif&quot;)</code></pre><p><img src="images/sim_lj.gif" alt="LJ simulation"/></p><h2><a class="nav-anchor" id="Simulating-diatomic-molecules-1" href="#Simulating-diatomic-molecules-1">Simulating diatomic molecules</a></h2><p>If we want to define specific interactions between atoms, for example bonds, we can do. Using the same atom definitions as before, let&#39;s set up the coordinates so that paired atoms are 1 Å apart.</p><pre><code class="language-julia">coords = [box_size .* rand(SVector{3}) for i in 1:(n_atoms / 2)]
for i in 1:length(coords)
    push!(coords, coords[i] .+ [0.1, 0.0, 0.0])
end

velocities = [velocity(mass, temperature) for i in 1:n_atoms]</code></pre><p>Now we can use the built-in bond type to place a harmonic constraint between paired atoms. The arguments are the indices of the two atoms in the bond, the equilibrium distance and the force constant.</p><pre><code class="language-julia">bonds = [HarmonicBond(i, Int(i + n_atoms / 2), 0.1, 300_000.0) for i in 1:Int(n_atoms / 2)]

specific_inter_lists = Dict(&quot;Bonds&quot; =&gt; bonds)</code></pre><p>This time, we are also going to use a neighbour list to speed up the Lennard Jones calculation. We can use the built-in distance neighbour finder. The arguments are a 2D array of eligible interactions, the number of steps between each update and the cutoff in nm to be classed as a neighbour.</p><pre><code class="language-julia">neighbour_finder = DistanceNeighbourFinder(trues(n_atoms, n_atoms), 10, 1.2)</code></pre><p>Now we can simulate as before.</p><pre><code class="language-julia">s = Simulation(
    simulator=VelocityVerlet(),
    atoms=atoms,
    specific_inter_lists=specific_inter_lists,
    general_inters=Dict(&quot;LJ&quot; =&gt; LennardJones(true)), # true means we are using the neighbour list for this interaction
    coords=coords,
    velocities=velocities,
    temperature=temperature,
    box_size=box_size,
    neighbour_finder=neighbour_finder,
    thermostat=AndersenThermostat(1.0),
    loggers=Dict(&quot;temp&quot; =&gt; TemperatureLogger(10),
                    &quot;coords&quot; =&gt; CoordinateLogger(10)),
    timestep=0.002,
    n_steps=1_000
)

simulate!(s)</code></pre><p>This time when we view the trajectory we can add lines to show the bonds.</p><pre><code class="language-julia">visualize(s.loggers[&quot;coords&quot;], box_size, &quot;sim_diatomic.gif&quot;,
            connections=[(i, Int(i + n_atoms / 2)) for i in 1:Int(n_atoms / 2)],
            markersize=0.05, linewidth=5.0)</code></pre><p><img src="images/sim_diatomic.gif" alt="Diatomic simulation"/></p><h2><a class="nav-anchor" id="Simulating-gravity-1" href="#Simulating-gravity-1">Simulating gravity</a></h2><p>Molly is geared primarily to molecular simulation, but can also be used to simulate other physical systems. Let&#39;s set up a gravitational simulation. This example also shows the use of <code>Float32</code> and a 2D simulation.</p><pre><code class="language-julia">atoms = [Atom(mass=1.0f0), Atom(mass=1.0f0)]
coords = [SVector(0.3f0, 0.5f0), SVector(0.7f0, 0.5f0)]
velocities = [SVector(0.0f0, 1.0f0), SVector(0.0f0, -1.0f0)]
general_inters = Dict(&quot;gravity&quot; =&gt; Gravity(false, 1.5f0))

s = Simulation(
    simulator=VelocityVerlet(),
    atoms=atoms,
    general_inters=general_inters,
    coords=coords,
    velocities=velocities,
    box_size=1.0f0,
    loggers=Dict(&quot;coords&quot; =&gt; CoordinateLogger(10, dims=2)),
    timestep=0.002f0,
    n_steps=2000
)

simulate!(s)</code></pre><p>When we view the simulation we can use some extra options:</p><pre><code class="language-julia">visualize(s.loggers[&quot;coords&quot;], 1.0f0, &quot;sim_gravity.gif&quot;,
            trails=4, framerate=15, color=[:orange, :lightgreen],
            markersize=0.05)</code></pre><p><img src="images/sim_gravity.gif" alt="Gravity simulation"/></p><h2><a class="nav-anchor" id="Simulating-a-protein-1" href="#Simulating-a-protein-1">Simulating a protein</a></h2><p>Molly has a rudimentary parser of <a href="http://www.gromacs.org">Gromacs</a> topology and coordinate files. Data for a protein can be read into the same data structures as above and simulated in the same way. Currently, the OPLS-AA forcefield is implemented.</p><pre><code class="language-julia">atoms, specific_inter_lists, general_inters, nb_matrix, coords, box_size = readinputs(
            joinpath(dirname(pathof(Molly)), &quot;..&quot;, &quot;data&quot;, &quot;5XER&quot;, &quot;gmx_top_ff.top&quot;),
            joinpath(dirname(pathof(Molly)), &quot;..&quot;, &quot;data&quot;, &quot;5XER&quot;, &quot;gmx_coords.gro&quot;))

temperature = 298

s = Simulation(
    simulator=VelocityVerlet(),
    atoms=atoms,
    specific_inter_lists=specific_inter_lists,
    general_inters=general_inters,
    coords=coords,
    velocities=[velocity(a.mass, temperature) for a in atoms],
    temperature=temperature,
    box_size=box_size,
    neighbour_finder=DistanceNeighbourFinder(nb_matrix, 10),
    thermostat=AndersenThermostat(1.0),
    loggers=Dict(&quot;temp&quot; =&gt; TemperatureLogger(10),
                    &quot;writer&quot; =&gt; StructureWriter(10, &quot;traj_5XER_1ps.pdb&quot;)),
    timestep=0.0002,
    n_steps=5_000
)

simulate!(s)</code></pre><h2><a class="nav-anchor" id="Forces-1" href="#Forces-1">Forces</a></h2><p>Forces define how different parts of the system interact. In Molly they are separated into two types. <a href="api.html#Molly.GeneralInteraction"><code>GeneralInteraction</code></a>s are present between all or most atoms, and account for example for non-bonded terms. <a href="api.html#Molly.SpecificInteraction"><code>SpecificInteraction</code></a>s are present between specific atoms, and account for example for bonded terms.</p><p>The available general interactions are:</p><ul><li><a href="api.html#Molly.LennardJones"><code>LennardJones</code></a>.</li><li><a href="api.html#Molly.Coulomb"><code>Coulomb</code></a>.</li><li><a href="api.html#Molly.Gravity"><code>Gravity</code></a>.</li></ul><p>The available specific interactions are:</p><ul><li><a href="api.html#Molly.HarmonicBond"><code>HarmonicBond</code></a>.</li><li><a href="api.html#Molly.HarmonicAngle"><code>HarmonicAngle</code></a>.</li><li><a href="api.html#Molly.Torsion"><code>Torsion</code></a>.</li></ul><p>To define your own <a href="api.html#Molly.GeneralInteraction"><code>GeneralInteraction</code></a>, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MyGeneralInter &lt;: GeneralInteraction
    nl_only::Bool
    # Any other properties, e.g. constants for the interaction
end</code></pre><p>The <code>nl_only</code> property is required and determines whether the neighbour list is used to omit distant atoms (<code>true</code>) or whether all atom pairs are always considered (<code>false</code>). Next, you need to define the <a href="api.html#Molly.force!"><code>force!</code></a> function acting between a pair of atoms. For example:</p><pre><code class="language-julia">function Molly.force!(forces, inter::MyGeneralInter, s::Simulation, i::Integer, j::Integer)
    dr = vector(s.coords[i], s.coords[j], s.box_size)

    # Replace this with your force calculation
    # A positive force causes the atoms to move apart
    f = 0.0

    fdr = f * normalize(dr)
    forces[i] -= fdr
    forces[j] += fdr
    return forces
end</code></pre><p>If you need to obtain the vector from atom <code>i</code> to atom <code>j</code>, use the <a href="api.html#Molly.vector-Tuple{Any,Any,Real}"><code>vector</code></a> function. This gets the vector between the closest images of atoms <code>i</code> and <code>j</code> accounting for the periodic boundary conditions. The <a href="api.html#Molly.Simulation"><code>Simulation</code></a> is available so atom properties or velocities can be accessed, e.g. <code>s.atoms[i].σ</code> or <code>s.velocities[i]</code>. This form of the function can also be used to define three-atom interactions by looping a third variable <code>k</code> up to <code>j</code> in the <a href="api.html#Molly.force!"><code>force!</code></a> function.</p><p>To use your custom force, add it to the dictionary of general interactions:</p><pre><code class="language-julia">general_inters = Dict(&quot;MyGeneralInter&quot; =&gt; MyGeneralInter(true))</code></pre><p>Then create and run a <a href="api.html#Molly.Simulation"><code>Simulation</code></a> as above.</p><p>To define your own <a href="api.html#Molly.SpecificInteraction"><code>SpecificInteraction</code></a>, first define the <code>struct</code>:</p><pre><code class="language-julia">struct MySpecificInter &lt;: SpecificInteraction
    # Any number of atoms involved in the interaction
    i::Int
    j::Int
    # Any other properties, e.g. a bond distance corresponding to the energy minimum
end</code></pre><p>Next, you need to define the <a href="api.html#Molly.force!"><code>force!</code></a> function. For example:</p><pre><code class="language-julia">function Molly.force!(forces, inter::MySpecificInter, s::Simulation)
    dr = vector(s.coords[inter.i], s.coords[inter.j], s.box_size)

    # Replace this with your force calculation
    # A positive force causes the atoms to move apart
    f = 0.0

    fdr = f * normalize(dr)
    forces[inter.i] += fdr
    forces[inter.j] -= fdr
    return forces
end</code></pre><p>The example here is between two atoms but can be adapted for any number of atoms. To use your custom force, add it to the dictionary of specific interaction lists:</p><pre><code class="language-julia">specific_inter_lists = Dict(&quot;MySpecificInter&quot; =&gt; [MySpecificInter(1, 2), MySpecificInter(3, 4)])</code></pre><h2><a class="nav-anchor" id="Simulators-1" href="#Simulators-1">Simulators</a></h2><p>Simulators define what type of simulation is run. This could be anything from a simple energy minimisation to complicated replica exchange MD. The available simulators are:</p><ul><li><a href="api.html#Molly.VelocityVerlet"><code>VelocityVerlet</code></a>.</li><li><a href="api.html#Molly.VelocityFreeVerlet"><code>VelocityFreeVerlet</code></a>.</li></ul><h2><a class="nav-anchor" id="Thermostats-1" href="#Thermostats-1">Thermostats</a></h2><p>Thermostats control the temperature over a simulation. The available thermostats are:</p><ul><li><a href="api.html#Molly.AndersenThermostat"><code>AndersenThermostat</code></a>.</li></ul><h2><a class="nav-anchor" id="Neighbour-finders-1" href="#Neighbour-finders-1">Neighbour finders</a></h2><p>Neighbour finders find close atoms periodically throughout the simulation, saving on computation time by allowing the force calculation between distance atoms to be omitted. The available neighbour finders are:</p><ul><li><a href="api.html#Molly.DistanceNeighbourFinder"><code>DistanceNeighbourFinder</code></a>.</li></ul><h2><a class="nav-anchor" id="Loggers-1" href="#Loggers-1">Loggers</a></h2><p>Loggers record properties of the simulation to allow monitoring and analysis. The available loggers are:</p><ul><li><a href="api.html#Molly.TemperatureLogger"><code>TemperatureLogger</code></a>.</li><li><a href="api.html#Molly.CoordinateLogger"><code>CoordinateLogger</code></a>.</li><li><a href="api.html#Molly.StructureWriter"><code>StructureWriter</code></a>.</li></ul><h2><a class="nav-anchor" id="Analysis-1" href="#Analysis-1">Analysis</a></h2><p>Molly contains some tools for analysing the results of simulations. The available analysis functions are:</p><ul><li><a href="api.html#Molly.visualize"><code>visualize</code></a>.</li><li><a href="api.html#Molly.rdf-Tuple{Any,Real}"><code>rdf</code></a>.</li><li><a href="api.html#Molly.distances-Tuple{Any,Real}"><code>distances</code></a>.</li><li><a href="api.html#Molly.displacements-Tuple{Any,Real}"><code>displacements</code></a>.</li></ul><footer><hr/><a class="previous" href="index.html"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="api.html"><span class="direction">Next</span><span class="title">API</span></a></footer></article></body></html>
